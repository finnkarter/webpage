<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>퍼즐 게임</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .puzzle-menu { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }
        .puzzle-card { background: var(--bg-dark); padding: 30px; border-radius: 15px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .puzzle-card:hover { background: var(--primary); color: white; transform: translateY(-5px); }
        .puzzle-icon { font-size: 3em; margin-bottom: 10px; }
        .game-container { display: none; background: var(--bg-dark); padding: 20px; border-radius: 20px; }
        .game-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; }
        
        /* 스도쿠 */
        .sudoku-grid { display: grid; grid-template-columns: repeat(9, 1fr); gap: 2px; max-width: 450px; margin: 20px auto; background: var(--border); padding: 3px; }
        .sudoku-cell { background: var(--bg-hover); aspect-ratio: 1; display: flex; align-items: center; justify-content: center; font-size: 1.2em; cursor: pointer; }
        .sudoku-cell input { background: transparent; border: none; width: 100%; height: 100%; text-align: center; font-size: 1.2em; color: var(--text-primary); }
        .sudoku-cell.fixed { background: var(--bg-card); font-weight: bold; cursor: default; }
        .sudoku-cell.selected { background: var(--primary); color: white; }
        .sudoku-cell:nth-child(3n):not(:nth-child(9n)) { margin-right: 3px; }
        .sudoku-cell:nth-child(n+19):nth-child(-n+27), .sudoku-cell:nth-child(n+46):nth-child(-n+54) { margin-bottom: 3px; }
        
        /* 지뢰찾기 */
        .mine-grid { display: grid; gap: 2px; max-width: 400px; margin: 20px auto; }
        .mine-cell { background: var(--bg-hover); aspect-ratio: 1; display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: bold; transition: all 0.2s; }
        .mine-cell:hover { background: var(--primary); }
        .mine-cell.revealed { background: var(--bg-card); cursor: default; }
        .mine-cell.mine { background: var(--danger); color: white; }
        .mine-cell.flag { background: var(--warning); }
        .mine-controls { text-align: center; margin: 20px 0; }
        
        /* 2048 */
        .game2048-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; max-width: 400px; margin: 20px auto; background: var(--bg-hover); padding: 10px; border-radius: 10px; }
        .tile2048 { background: var(--bg-card); aspect-ratio: 1; display: flex; align-items: center; justify-content: center; font-size: 1.5em; font-weight: bold; border-radius: 5px; }
        .tile-2 { background: #eee4da; color: #776e65; }
        .tile-4 { background: #ede0c8; color: #776e65; }
        .tile-8 { background: #f2b179; color: #f9f6f2; }
        .tile-16 { background: #f59563; color: #f9f6f2; }
        .tile-32 { background: #f67c5f; color: #f9f6f2; }
        .tile-64 { background: #f65e3b; color: #f9f6f2; }
        
        @media (max-width: 768px) {
            .sudoku-cell { font-size: 1em; }
            .mine-grid { max-width: 300px; }
            .game2048-grid { max-width: 300px; }
            .tile2048 { font-size: 1.2em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-header">
            <a href="index.html" class="back-btn">← 뒤로</a>
            <h1>퍼즐 게임</h1>
        </div>
        
        <div class="content">
            <div class="puzzle-menu" id="puzzleMenu">
                <div class="puzzle-card" onclick="startPuzzle('sudoku')">
                    <div class="puzzle-icon">🔢</div>
                    <h3>스도쿠</h3>
                    <p>숫자 퍼즐</p>
                </div>
                <div class="puzzle-card" onclick="startPuzzle('mine')">
                    <div class="puzzle-icon">💣</div>
                    <h3>지뢰찾기</h3>
                    <p>지뢰 피하기</p>
                </div>
                <div class="puzzle-card" onclick="startPuzzle('game2048')">
                    <div class="puzzle-icon">🎲</div>
                    <h3>2048</h3>
                    <p>숫자 합치기</p>
                </div>
            </div>
            
            <!-- 스도쿠 -->
            <div class="game-container" id="sudokuGame">
                <div class="game-header">
                    <h2>스도쿠</h2>
                    <button onclick="backToMenu()">메뉴로</button>
                </div>
                <div class="sudoku-grid" id="sudokuGrid"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="newSudoku()">새 게임</button>
                    <button onclick="checkSudoku()">확인</button>
                </div>
            </div>
            
            <!-- 지뢰찾기 -->
            <div class="game-container" id="mineGame">
                <div class="game-header">
                    <h2>지뢰찾기</h2>
                    <button onclick="backToMenu()">메뉴로</button>
                </div>
                <div class="mine-controls">
                    <span>💣 지뢰: <span id="mineCount">10</span></span> | 
                    <span>🚩 깃발: <span id="flagCount">0</span></span> | 
                    <span>⏱️ 시간: <span id="mineTime">0</span>초</span>
                </div>
                <div class="mine-grid" id="mineGrid"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="newMine()">새 게임</button>
                    <select id="mineLevel" onchange="newMine()">
                        <option value="easy">쉬움 (9x9)</option>
                        <option value="medium">보통 (16x16)</option>
                        <option value="hard">어려움 (16x30)</option>
                    </select>
                </div>
            </div>
            
            <!-- 2048 -->
            <div class="game-container" id="game2048Game">
                <div class="game-header">
                    <h2>2048</h2>
                    <button onclick="backToMenu()">메뉴로</button>
                </div>
                <div style="text-align: center; margin: 20px 0;">
                    <h3>점수: <span id="score2048">0</span></h3>
                    <p>방향키나 스와이프로 움직이세요</p>
                </div>
                <div class="game2048-grid" id="grid2048"></div>
                <div style="text-align: center; margin-top: 20px;">
                    <button onclick="new2048()">새 게임</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 퍼즐 메뉴
        function startPuzzle(game) {
            document.getElementById('puzzleMenu').style.display = 'none';
            document.querySelectorAll('.game-container').forEach(g => g.style.display = 'none');
            document.getElementById(game + 'Game').style.display = 'block';
            
            if (game === 'sudoku') newSudoku();
            else if (game === 'mine') newMine();
            else if (game === 'game2048') new2048();
        }
        
        function backToMenu() {
            document.querySelectorAll('.game-container').forEach(g => g.style.display = 'none');
            document.getElementById('puzzleMenu').style.display = 'grid';
        }
        
        // 스도쿠
        let sudokuSolution = [];
        function newSudoku() {
            // 간단한 스도쿠 생성 (실제로는 더 복잡한 알고리즘 필요)
            const grid = document.getElementById('sudokuGrid');
            grid.innerHTML = '';
            
            // 예시 퍼즐
            const puzzle = [
                5,3,0,0,7,0,0,0,0,
                6,0,0,1,9,5,0,0,0,
                0,9,8,0,0,0,0,6,0,
                8,0,0,0,6,0,0,0,3,
                4,0,0,8,0,3,0,0,1,
                7,0,0,0,2,0,0,0,6,
                0,6,0,0,0,0,2,8,0,
                0,0,0,4,1,9,0,0,5,
                0,0,0,0,8,0,0,7,9
            ];
            
            puzzle.forEach((num, i) => {
                const cell = document.createElement('div');
                cell.className = 'sudoku-cell';
                if (num !== 0) {
                    cell.textContent = num;
                    cell.classList.add('fixed');
                } else {
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.min = '1';
                    input.max = '9';
                    cell.appendChild(input);
                }
                grid.appendChild(cell);
            });
        }
        
        function checkSudoku() {
            alert('스도쿠 확인 기능은 아직 구현 중입니다!');
        }
        
        // 지뢰찾기
        let mineField = [];
        let mineTimer = null;
        let mineStartTime = 0;
        
        function newMine() {
            const level = document.getElementById('mineLevel').value;
            const sizes = { easy: [9, 9, 10], medium: [16, 16, 40], hard: [16, 30, 99] };
            const [rows, cols, mines] = sizes[level];
            
            // 지뢰 배치
            mineField = Array(rows).fill().map(() => Array(cols).fill(0));
            let placed = 0;
            while (placed < mines) {
                const r = Math.floor(Math.random() * rows);
                const c = Math.floor(Math.random() * cols);
                if (mineField[r][c] !== -1) {
                    mineField[r][c] = -1;
                    placed++;
                    // 주변 숫자 증가
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dc = -1; dc <= 1; dc++) {
                            if (r+dr >= 0 && r+dr < rows && c+dc >= 0 && c+dc < cols && mineField[r+dr][c+dc] !== -1) {
                                mineField[r+dr][c+dc]++;
                            }
                        }
                    }
                }
            }
            
            // 그리드 생성
            const grid = document.getElementById('mineGrid');
            grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            grid.innerHTML = '';
            
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'mine-cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.onclick = () => revealCell(r, c);
                    cell.oncontextmenu = (e) => { e.preventDefault(); flagCell(r, c); };
                    grid.appendChild(cell);
                }
            }
            
            document.getElementById('mineCount').textContent = mines;
            document.getElementById('flagCount').textContent = 0;
            document.getElementById('mineTime').textContent = 0;
            
            clearInterval(mineTimer);
            mineStartTime = Date.now();
            mineTimer = setInterval(() => {
                document.getElementById('mineTime').textContent = Math.floor((Date.now() - mineStartTime) / 1000);
            }, 1000);
        }
        
        function revealCell(r, c) {
            const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            if (cell.classList.contains('revealed') || cell.classList.contains('flag')) return;
            
            cell.classList.add('revealed');
            if (mineField[r][c] === -1) {
                cell.classList.add('mine');
                cell.textContent = '💣';
                clearInterval(mineTimer);
                alert('게임 오버!');
            } else if (mineField[r][c] > 0) {
                cell.textContent = mineField[r][c];
                cell.style.color = ['', 'blue', 'green', 'red', 'darkblue', 'brown', 'cyan', 'black', 'gray'][mineField[r][c]];
            } else {
                // 빈 칸 자동 열기
                const rows = mineField.length;
                const cols = mineField[0].length;
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (r+dr >= 0 && r+dr < rows && c+dc >= 0 && c+dc < cols) {
                            revealCell(r+dr, c+dc);
                        }
                    }
                }
            }
        }
        
        function flagCell(r, c) {
            const cell = document.querySelector(`[data-row="${r}"][data-col="${c}"]`);
            if (cell.classList.contains('revealed')) return;
            
            if (cell.classList.contains('flag')) {
                cell.classList.remove('flag');
                cell.textContent = '';
                document.getElementById('flagCount').textContent = parseInt(document.getElementById('flagCount').textContent) - 1;
            } else {
                cell.classList.add('flag');
                cell.textContent = '🚩';
                document.getElementById('flagCount').textContent = parseInt(document.getElementById('flagCount').textContent) + 1;
            }
        }
        
        // 2048
        let grid2048 = [];
        let score2048 = 0;
        
        function new2048() {
            grid2048 = Array(4).fill().map(() => Array(4).fill(0));
            score2048 = 0;
            document.getElementById('score2048').textContent = 0;
            addNewTile();
            addNewTile();
            updateGrid2048();
        }
        
        function addNewTile() {
            const empty = [];
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (grid2048[r][c] === 0) empty.push([r, c]);
                }
            }
            if (empty.length > 0) {
                const [r, c] = empty[Math.floor(Math.random() * empty.length)];
                grid2048[r][c] = Math.random() < 0.9 ? 2 : 4;
            }
        }
        
        function updateGrid2048() {
            const gridEl = document.getElementById('grid2048');
            gridEl.innerHTML = '';
            
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile2048';
                    if (grid2048[r][c] > 0) {
                        tile.classList.add(`tile-${grid2048[r][c]}`);
                        tile.textContent = grid2048[r][c];
                    }
                    gridEl.appendChild(tile);
                }
            }
        }
        
        function move2048(direction) {
            let moved = false;
            const newGrid = grid2048.map(row => [...row]);
            
            // 간단한 이동 로직 (실제로는 더 복잡)
            if (direction === 'left') {
                for (let r = 0; r < 4; r++) {
                    const row = newGrid[r].filter(x => x > 0);
                    for (let i = 0; i < row.length - 1; i++) {
                        if (row[i] === row[i + 1]) {
                            row[i] *= 2;
                            score2048 += row[i];
                            row.splice(i + 1, 1);
                        }
                    }
                    while (row.length < 4) row.push(0);
                    if (row.join(',') !== newGrid[r].join(',')) moved = true;
                    newGrid[r] = row;
                }
            }
            
            if (moved) {
                grid2048 = newGrid;
                addNewTile();
                updateGrid2048();
                document.getElementById('score2048').textContent = score2048;
            }
        }
        
        // 키보드 이벤트
        document.addEventListener('keydown', (e) => {
            if (document.getElementById('game2048Game').style.display === 'block') {
                if (e.key === 'ArrowLeft') move2048('left');
                else if (e.key === 'ArrowRight') move2048('right');
                else if (e.key === 'ArrowUp') move2048('up');
                else if (e.key === 'ArrowDown') move2048('down');
            }
        });
        
        // 2048 이동 로직 완성
        function move2048(direction) {
            let moved = false;
            const newGrid = grid2048.map(row => [...row]);
            
            if (direction === 'left') {
                for (let r = 0; r < 4; r++) {
                    const row = newGrid[r].filter(x => x > 0);
                    for (let i = 0; i < row.length - 1; i++) {
                        if (row[i] === row[i + 1]) {
                            row[i] *= 2;
                            score2048 += row[i];
                            row.splice(i + 1, 1);
                        }
                    }
                    while (row.length < 4) row.push(0);
                    if (row.join(',') !== newGrid[r].join(',')) moved = true;
                    newGrid[r] = row;
                }
            } else if (direction === 'right') {
                for (let r = 0; r < 4; r++) {
                    const row = newGrid[r].filter(x => x > 0);
                    for (let i = row.length - 1; i > 0; i--) {
                        if (row[i] === row[i - 1]) {
                            row[i] *= 2;
                            score2048 += row[i];
                            row.splice(i - 1, 1);
                            i--;
                        }
                    }
                    while (row.length < 4) row.unshift(0);
                    if (row.join(',') !== newGrid[r].join(',')) moved = true;
                    newGrid[r] = row;
                }
            } else if (direction === 'up') {
                for (let c = 0; c < 4; c++) {
                    const col = [];
                    for (let r = 0; r < 4; r++) {
                        if (newGrid[r][c] > 0) col.push(newGrid[r][c]);
                    }
                    for (let i = 0; i < col.length - 1; i++) {
                        if (col[i] === col[i + 1]) {
                            col[i] *= 2;
                            score2048 += col[i];
                            col.splice(i + 1, 1);
                        }
                    }
                    while (col.length < 4) col.push(0);
                    for (let r = 0; r < 4; r++) {
                        if (newGrid[r][c] !== col[r]) moved = true;
                        newGrid[r][c] = col[r];
                    }
                }
            } else if (direction === 'down') {
                for (let c = 0; c < 4; c++) {
                    const col = [];
                    for (let r = 0; r < 4; r++) {
                        if (newGrid[r][c] > 0) col.push(newGrid[r][c]);
                    }
                    for (let i = col.length - 1; i > 0; i--) {
                        if (col[i] === col[i - 1]) {
                            col[i] *= 2;
                            score2048 += col[i];
                            col.splice(i - 1, 1);
                            i--;
                        }
                    }
                    while (col.length < 4) col.unshift(0);
                    for (let r = 0; r < 4; r++) {
                        if (newGrid[r][c] !== col[r]) moved = true;
                        newGrid[r][c] = col[r];
                    }
                }
            }
            
            if (moved) {
                grid2048 = newGrid;
                addNewTile();
                updateGrid2048();
                document.getElementById('score2048').textContent = score2048;
                
                // 게임 오버 체크
                if (isGameOver2048()) {
                    alert(`게임 오버! 최종 점수: ${score2048}`);
                    new2048();
                }
            }
        }
        
        function isGameOver2048() {
            // 빈 칸이 있으면 계속 가능
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (grid2048[r][c] === 0) return false;
                }
            }
            
            // 인접한 같은 숫자가 있으면 계속 가능
            for (let r = 0; r < 4; r++) {
                for (let c = 0; c < 4; c++) {
                    if (c < 3 && grid2048[r][c] === grid2048[r][c + 1]) return false;
                    if (r < 3 && grid2048[r][c] === grid2048[r + 1][c]) return false;
                }
            }
            
            return true;
        }
    </script>
</body>
</html>